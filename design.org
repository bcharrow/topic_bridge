#+TITLE:     design.org
#+AUTHOR:    Ben Charrow
#+EMAIL:     bcharrow@seas.upenn.edu
#+DATE:      2012-06-28 Thu
#+DESCRIPTION: Design goals for topic_bridge
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:nil skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

* Overview

topic\_bridge enables robots on separate machines to communicate when they do
not use the same ROS master.

Each ROS master should have a single topic\_bridge node. The node listens to
specified topics via ROS' communication infrastructure, and sends messages it
receives to other topic\_bridge nodes on other ROS masters via UDP.  Upon
receiving a message from a foreign topic\_bridge, the local topic\_bridge will
broadcast the message locally via ROS' communication infrastructure.

Bridges can be one way or two way.  A one way bridge between two computers
would mean one machine sends its local messages to the other computer, but the
reverse does not happen.  Bridges are configured on a per-topic basis.

* Usage
 Assuming you have a topic\_bridge running on local master.

 Get messages from 192.168.130.27:8080/test forwarded to local machine.
 : rosservice call /topic_bridge/topic "{ip: '192.168.130.27', port: 8080, 
 :   mtype: 'std_msgs/String', topic: '/test'}"

 Send / get messages between localhost and 192.168.130.27:8080 (2-way bridge)
 : rosservice call /topic_bridge/topic "{ip: '192.168.130.27', port: 808,0hi 
 :   mtype: 'std_msgs/String', topic: '/test', action: 1}"

* Design notes

- Because UDP is the transport protocol for communication between bridges,
  messages may arrive out of order or not at all.
- ROS parameters are not supported.
- ROS services are not supported.
- Assumes synchronized clocks between machines.
- No service discovery.
- Everything is implemented using rospy.  roscpp is difficult to use because it
  has no introspection and it would require compile time specification of
  supported types.  See ros::Subscriber, ros::Publisher,
  ros::NodeHandle::advertise() and ros::AdvertiseOptions for more details.

* Mesh notes
I've measured the following on a mesh 802.11S network using the Scarabs.

- Ping time between two bots is ~2ms.
- When transferring a file from one scarab to another via scp, the max data
  rate is 2.8 MB/s and about 30% of the CPU is used.
- If you send zeros via UDP from one scarab to another via netcat, the max data
  rate is 3.3 MB/s, but it occasionally drops to 2.2 MB/s.  This variance is
  due to small default send / receive UDP buffer sizes.  At these rates, the
  sender has ~4% CPU utilization, while the receiver has ~2% utilization.

  Sender command
  : cat /dev/zero | netcat -u 192.168.130.28 8080
  Receiver command
  : netcat -l -u -p 8080 | pv > /dev/null
  Check dropped UDP packets
  : netstat -su
